/* awn-panel-dispatcher.c generated by valac 0.12.1, the Vala compiler
 * generated from awn-panel-dispatcher.vala, do not modify */

/*
 * Copyright (C) 2010 Michal Hruby <michal.mhr@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA.
 *
 * Authored by Michal Hruby <michal.mhr@gmail.com>
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <dbus/dbus-glib.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <dbus/dbus.h>
#include "awn-panel.h"
#include "awn-panel-dispatcher.h"
#include <libawn/vala-utils.h>
#include <string>

typedef struct _DBusObjectVTable _DBusObjectVTable;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _AwnPanelDBusInterfaceDBusProxy AwnPanelDBusInterfaceDBusProxy;
typedef DBusGProxyClass AwnPanelDBusInterfaceDBusProxyClass;
#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))

struct _DBusObjectVTable {
    void (*register_object)(DBusConnection*, const char*, void*);
};

struct _AwnPanelDBusInterfaceDBusProxy {
    DBusGProxy parent_instance;
    gboolean disposed;
};

struct AwnPanelDispatcherPrivate {
    AwnPanel* _panel;
};


static gpointer awn_panel_dispatcher_parent_class = NULL;
static AwnPanelDBusInterfaceIface* awn_panel_dispatcher_awn_panel_dbus_interface_parent_iface = NULL;

static gchar* _vala_array_dup1(gchar* self, int length);
static void g_cclosure_user_marshal_VOID__STRING_BOXED(GClosure* closure, GValue* return_value, guint n_param_values, const GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
static void _vala_dbus_register_object(DBusConnection* connection, const char* path, void* object);
static void _vala_dbus_unregister_object(gpointer connection, GObject* object);
void awn_panel_dbus_interface_dbus_register_object(DBusConnection* connection, const char* path, void* object);
void _awn_panel_dbus_interface_dbus_unregister(DBusConnection* connection, void* _user_data_);
DBusHandlerResult awn_panel_dbus_interface_dbus_message(DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_awn_panel_dbus_interface_introspect(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_awn_panel_dbus_interface_property_get(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_awn_panel_dbus_interface_property_set(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_awn_panel_dbus_interface_property_get_all(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_awn_panel_dbus_interface_add_applet(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_awn_panel_dbus_interface_delete_applet(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_awn_panel_dbus_interface_docklet_request(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_awn_panel_dbus_interface_get_inhibitors(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_awn_panel_dbus_interface_get_snapshot(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_awn_panel_dbus_interface_inhibit_autohide(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_awn_panel_dbus_interface_uninhibit_autohide(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_awn_panel_dbus_interface_set_applet_flags(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_awn_panel_dbus_interface_set_glow(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_awn_panel_dbus_interface_destroy_applet(GObject* _sender, const gchar* uid, DBusConnection* _connection);
static void _dbus_awn_panel_dbus_interface_destroy_notify(GObject* _sender, DBusConnection* _connection);
static void _dbus_awn_panel_dbus_interface_property_changed(GObject* _sender, const gchar* prop_name, GValue* value, DBusConnection* _connection);
extern "C" GType awn_panel_dbus_interface_dbus_proxy_get_type(void) G_GNUC_CONST;
static void _dbus_handle_awn_panel_dbus_interface_destroy_applet(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_handle_awn_panel_dbus_interface_destroy_notify(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_handle_awn_panel_dbus_interface_property_changed(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message);
DBusHandlerResult awn_panel_dbus_interface_dbus_proxy_filter(DBusConnection* connection, DBusMessage* message, void* user_data);
enum  {
    AWN_PANEL_DBUS_INTERFACE_DBUS_PROXY_DUMMY_PROPERTY
};
static void awn_panel_dbus_interface_dbus_proxy_add_applet(AwnPanelDBusInterface* self, const gchar* desktop_file, GError** error);
static void awn_panel_dbus_interface_dbus_proxy_delete_applet(AwnPanelDBusInterface* self, const gchar* uid, GError** error);
static gint64 awn_panel_dbus_interface_dbus_proxy_docklet_request(AwnPanelDBusInterface* self, gint min_size, gboolean shrink, gboolean expand, GError** error);
static gchar** awn_panel_dbus_interface_dbus_proxy_get_inhibitors(AwnPanelDBusInterface* self, int* result_length1, GError** error);
static void awn_panel_dbus_interface_dbus_proxy_get_snapshot(AwnPanelDBusInterface* self, AwnImageStruct* result, GError** error);
static guint awn_panel_dbus_interface_dbus_proxy_inhibit_autohide(AwnPanelDBusInterface* self, const char* sender, const gchar* app_name, const gchar* reason, GError** error);
static void awn_panel_dbus_interface_dbus_proxy_uninhibit_autohide(AwnPanelDBusInterface* self, guint cookie, GError** error);
static void awn_panel_dbus_interface_dbus_proxy_set_applet_flags(AwnPanelDBusInterface* self, const gchar* uid, gint flags, GError** error);
static void awn_panel_dbus_interface_dbus_proxy_set_glow(AwnPanelDBusInterface* self, const char* sender, gboolean activate, GError** error);
static gdouble awn_panel_dbus_interface_dbus_proxy_get_offset_modifier(AwnPanelDBusInterface* self);
static gint awn_panel_dbus_interface_dbus_proxy_get_max_size(AwnPanelDBusInterface* self);
static gint awn_panel_dbus_interface_dbus_proxy_get_offset(AwnPanelDBusInterface* self);
static void awn_panel_dbus_interface_dbus_proxy_set_offset(AwnPanelDBusInterface* self, gint value);
static gint awn_panel_dbus_interface_dbus_proxy_get_path_type(AwnPanelDBusInterface* self);
static gint awn_panel_dbus_interface_dbus_proxy_get_position(AwnPanelDBusInterface* self);
static void awn_panel_dbus_interface_dbus_proxy_set_position(AwnPanelDBusInterface* self, gint value);
static gint awn_panel_dbus_interface_dbus_proxy_get_size(AwnPanelDBusInterface* self);
static void awn_panel_dbus_interface_dbus_proxy_set_size(AwnPanelDBusInterface* self, gint value);
static gint64 awn_panel_dbus_interface_dbus_proxy_get_panel_xid(AwnPanelDBusInterface* self);
static void awn_panel_dbus_interface_dbus_proxy_awn_panel_dbus_interface__interface_init(AwnPanelDBusInterfaceIface* iface);
static void _vala_awn_panel_dbus_interface_dbus_proxy_get_property(GObject* object, guint property_id, GValue* value, GParamSpec* pspec);
static void _vala_awn_panel_dbus_interface_dbus_proxy_set_property(GObject* object, guint property_id, const GValue* value, GParamSpec* pspec);
#define AWN_PANEL_DISPATCHER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), AWN_TYPE_PANEL_DISPATCHER, AwnPanelDispatcherPrivate))
enum  {
    AWN_PANEL_DISPATCHER_DUMMY_PROPERTY,
    AWN_PANEL_DISPATCHER_PANEL
};
static void _lambda0_(AwnPanel* p, gint s, AwnPanelDispatcher* self);
static void __lambda0__awn_panel_size_changed(AwnPanel* _sender, gint size, gpointer self);
static void _lambda1_(AwnPanel* p, gint pos, AwnPanelDispatcher* self);
static void __lambda1__awn_panel_position_changed(AwnPanel* _sender, gint position, gpointer self);
static void _lambda2_(AwnPanel* p, gint o, AwnPanelDispatcher* self);
static void __lambda2__awn_panel_offset_changed(AwnPanel* _sender, gint offset, gpointer self);
static void _lambda3_(AwnPanel* p, const gchar* pn, GValue* v, AwnPanelDispatcher* self);
static void __lambda3__awn_panel_property_changed(AwnPanel* _sender, const gchar* prop_name, GValue* val, gpointer self);
static void awn_panel_dispatcher_real_add_applet(AwnPanelDBusInterface* base, const gchar* desktop_file, GError** error);
AwnPanel* awn_panel_dispatcher_get_panel(AwnPanelDispatcher* self);
static void awn_panel_dispatcher_real_delete_applet(AwnPanelDBusInterface* base, const gchar* uid, GError** error);
static gint64 awn_panel_dispatcher_real_docklet_request(AwnPanelDBusInterface* base, gint min_size, gboolean shrink, gboolean expand, GError** error);
static gchar** awn_panel_dispatcher_real_get_inhibitors(AwnPanelDBusInterface* base, int* result_length1, GError** error);
static void awn_panel_dispatcher_real_get_snapshot(AwnPanelDBusInterface* base, AwnImageStruct* result, GError** error);
static guint awn_panel_dispatcher_real_inhibit_autohide(AwnPanelDBusInterface* base, const char* sender, const gchar* app_name, const gchar* reason, GError** error);
static void awn_panel_dispatcher_real_uninhibit_autohide(AwnPanelDBusInterface* base, guint cookie, GError** error);
static void awn_panel_dispatcher_real_set_applet_flags(AwnPanelDBusInterface* base, const gchar* uid, gint flags, GError** error);
static void awn_panel_dispatcher_real_set_glow(AwnPanelDBusInterface* base, const char* sender, gboolean activate, GError** error);
static void awn_panel_dispatcher_set_panel(AwnPanelDispatcher* self, AwnPanel* value);
static void awn_panel_dispatcher_finalize(GObject* obj);
void awn_panel_dispatcher_dbus_register_object(DBusConnection* connection, const char* path, void* object);
void _awn_panel_dispatcher_dbus_unregister(DBusConnection* connection, void* _user_data_);
DBusHandlerResult awn_panel_dispatcher_dbus_message(DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_awn_panel_dispatcher_introspect(AwnPanelDispatcher* self, DBusConnection* connection, DBusMessage* message);
static void _vala_awn_panel_dispatcher_get_property(GObject* object, guint property_id, GValue* value, GParamSpec* pspec);
static void _vala_awn_panel_dispatcher_set_property(GObject* object, guint property_id, const GValue* value, GParamSpec* pspec);
static gint _vala_array_length(gpointer array);

static const DBusObjectPathVTable _awn_panel_dbus_interface_dbus_path_vtable = {_awn_panel_dbus_interface_dbus_unregister, awn_panel_dbus_interface_dbus_message};
static const _DBusObjectVTable _awn_panel_dbus_interface_dbus_vtable = {awn_panel_dbus_interface_dbus_register_object};
static const DBusObjectPathVTable _awn_panel_dispatcher_dbus_path_vtable = {_awn_panel_dispatcher_dbus_unregister, awn_panel_dispatcher_dbus_message};
static const _DBusObjectVTable _awn_panel_dispatcher_dbus_vtable = {awn_panel_dispatcher_dbus_register_object};

static gchar* _vala_array_dup1(gchar* self, int length)
{
    return g_memdup(self, length * sizeof(gchar));
}


void awn_image_struct_copy(const AwnImageStruct* self, AwnImageStruct* dest)
{
    *dest = *self;
    char* tmp = self->pixel_data;
    dest->pixel_data = (tmp == NULL) ? nullptr :  _vala_array_dup1(tmp, (*self).pixel_data_length1);
}


void awn_image_struct_destroy(AwnImageStruct* self)
{
    (*self).pixel_data = (g_free((*self).pixel_data), NULL);
}


AwnImageStruct* awn_image_struct_dup(const AwnImageStruct* self)
{
    AwnImageStruct* dup = new AwnImageStruct;
    awn_image_struct_copy(self, dup);
    return dup;
}


void awn_image_struct_free(AwnImageStruct* self)
{
    awn_image_struct_destroy(self);
    delete self;
}


GType awn_image_struct_get_type(void)
{
    static volatile gsize type_id = 0;
    if (g_once_init_enter(&type_id)) {
        GType awn_image_struct_type_id;
        awn_image_struct_type_id = g_boxed_type_register_static("AwnImageStruct", (GBoxedCopyFunc) awn_image_struct_dup, (GBoxedFreeFunc) awn_image_struct_free);
        g_once_init_leave(&type_id, awn_image_struct_type_id);
    }
    return type_id;
}


void awn_panel_dbus_interface_add_applet(AwnPanelDBusInterface* self, const gchar* desktop_file, GError** error)
{
    AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->add_applet(self, desktop_file, error);
}


void awn_panel_dbus_interface_delete_applet(AwnPanelDBusInterface* self, const gchar* uid, GError** error)
{
    AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->delete_applet(self, uid, error);
}


gint64 awn_panel_dbus_interface_docklet_request(AwnPanelDBusInterface* self, gint min_size, gboolean shrink, gboolean expand, GError** error)
{
    return AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->docklet_request(self, min_size, shrink, expand, error);
}


gchar** awn_panel_dbus_interface_get_inhibitors(AwnPanelDBusInterface* self, int* result_length1, GError** error)
{
    return AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->get_inhibitors(self, result_length1, error);
}


void awn_panel_dbus_interface_get_snapshot(AwnPanelDBusInterface* self, AwnImageStruct* result, GError** error)
{
    AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->get_snapshot(self, result, error);
}


guint awn_panel_dbus_interface_inhibit_autohide(AwnPanelDBusInterface* self, const char* sender, const gchar* app_name, const gchar* reason, GError** error)
{
    return AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->inhibit_autohide(self, sender, app_name, reason, error);
}


void awn_panel_dbus_interface_uninhibit_autohide(AwnPanelDBusInterface* self, guint cookie, GError** error)
{
    AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->uninhibit_autohide(self, cookie, error);
}


void awn_panel_dbus_interface_set_applet_flags(AwnPanelDBusInterface* self, const gchar* uid, gint flags, GError** error)
{
    AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->set_applet_flags(self, uid, flags, error);
}


void awn_panel_dbus_interface_set_glow(AwnPanelDBusInterface* self, const char* sender, gboolean activate, GError** error)
{
    AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->set_glow(self, sender, activate, error);
}


gdouble awn_panel_dbus_interface_get_offset_modifier(AwnPanelDBusInterface* self)
{
    return AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->get_offset_modifier(self);
}


gint awn_panel_dbus_interface_get_max_size(AwnPanelDBusInterface* self)
{
    return AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->get_max_size(self);
}


gint awn_panel_dbus_interface_get_offset(AwnPanelDBusInterface* self)
{
    return AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->get_offset(self);
}


void awn_panel_dbus_interface_set_offset(AwnPanelDBusInterface* self, gint value)
{
    AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->set_offset(self, value);
}


gint awn_panel_dbus_interface_get_path_type(AwnPanelDBusInterface* self)
{
    return AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->get_path_type(self);
}


gint awn_panel_dbus_interface_get_position(AwnPanelDBusInterface* self)
{
    return AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->get_position(self);
}


void awn_panel_dbus_interface_set_position(AwnPanelDBusInterface* self, gint value)
{
    AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->set_position(self, value);
}


gint awn_panel_dbus_interface_get_size(AwnPanelDBusInterface* self)
{
    return AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->get_size(self);
}


void awn_panel_dbus_interface_set_size(AwnPanelDBusInterface* self, gint value)
{
    AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->set_size(self, value);
}


gint64 awn_panel_dbus_interface_get_panel_xid(AwnPanelDBusInterface* self)
{
    return AWN_PANEL_DBUS_INTERFACE_GET_INTERFACE(self)->get_panel_xid(self);
}


static void g_cclosure_user_marshal_VOID__STRING_BOXED(
        GClosure* closure, GValue* return_value, guint n_param_values,
        const GValue* param_values, gpointer invocation_hint,
        gpointer marshal_data)
{
    typedef void (*GMarshalFunc_VOID__STRING_BOXED)(gpointer data1, const char * arg_1, gpointer arg_2, gpointer data2);
    GMarshalFunc_VOID__STRING_BOXED callback;
    void* data1;
    void* data2;
    GCClosure* cc = (GCClosure*) closure;
    g_return_if_fail(n_param_values == 3);
    if (G_CCLOSURE_SWAP_DATA(closure)) {
        data1 = closure->data;
        data2 = param_values->data[0].v_pointer;
    } else {
        data1 = param_values->data[0].v_pointer;
        data2 = closure->data;
    }
    callback = (GMarshalFunc_VOID__STRING_BOXED)(marshal_data ? marshal_data : cc->callback);
    callback(data1, g_value_get_string(param_values + 1), g_value_get_boxed(param_values + 2), data2);
}


static void awn_panel_dbus_interface_base_init(AwnPanelDBusInterfaceIface* iface)
{
    static bool initialized = false;
    if (!initialized) {
        initialized = true;
        g_signal_new("destroy_applet", AWN_TYPE_PANEL_DBUS_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
        g_signal_new("destroy_notify", AWN_TYPE_PANEL_DBUS_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
        g_signal_new("property_changed", AWN_TYPE_PANEL_DBUS_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_BOXED, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_VALUE);
    }
}


static void _vala_dbus_register_object(DBusConnection* connection, const char* path, void* object)
{
    const _DBusObjectVTable* vtable = g_type_get_qdata(G_TYPE_FROM_INSTANCE(object),
                                                       g_quark_from_static_string("DBusObjectVTable"));
    if (vtable) {
        vtable->register_object(connection, path, object);
    } else {
        g_warning("Object does not implement any D-Bus interface");
    }
}


static void _vala_dbus_unregister_object(gpointer connection, GObject* object)
{
    char* path = g_object_steal_data((GObject*) object, "dbus_object_path");
    dbus_connection_unregister_object_path(connection, path);
    g_free(path);
}


void _awn_panel_dbus_interface_dbus_unregister(DBusConnection* connection, void* _user_data_)
{
}


static DBusHandlerResult _dbus_awn_panel_dbus_interface_introspect(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    char** children;
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);

    std::string xml_data{"<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n"};
    xml_data += "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"org.awnproject.Awn.Panel\">\n  <method name=\"AddApplet\">\n    <arg name=\"desktop_file\" type=\"s\" direction=\"in\"/>\n  </method>\n  <method name=\"DeleteApplet\">\n    <arg name=\"uid\" type=\"s\" direction=\"in\"/>\n  </method>\n  <method name=\"DockletRequest\">\n    <arg name=\"min_size\" type=\"i\" direction=\"in\"/>\n    <arg name=\"shrink\" type=\"b\" direction=\"in\"/>\n    <arg name=\"expand\" type=\"b\" direction=\"in\"/>\n    <arg name=\"result\" type=\"x\" direction=\"out\"/>\n  </method>\n  <method name=\"GetInhibitors\">\n    <arg name=\"result\" type=\"as\" direction=\"out\"/>\n  </method>\n  <method name=\"GetSnapshot\">\n    <arg name=\"result\" type=\"(iiibiiay)\" direction=\"out\"/>\n  </method>\n  <method name=\"InhibitAutohide\">\n    <arg name=\"app_name\" type=\"s\" direction=\"in\"/>\n    <arg name=\"reason\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"u\" direction=\"out\"/>\n  </method>\n  <method name=\"UninhibitAutohide\">\n    <arg name=\"cookie\" type=\"u\" direction=\"in\"/>\n  </method>\n  <method name=\"SetAppletFlags\">\n    <arg name=\"uid\" type=\"s\" direction=\"in\"/>\n    <arg name=\"flags\" type=\"i\" direction=\"in\"/>\n  </method>\n  <method name=\"SetGlow\">\n    <arg name=\"activate\" type=\"b\" direction=\"in\"/>\n  </method>\n  <property name=\"OffsetModifier\" type=\"d\" access=\"read\"/>\n  <property name=\"MaxSize\" type=\"i\" access=\"read\"/>\n  <property name=\"Offset\" type=\"i\" access=\"readwrite\"/>\n  <property name=\"PathType\" type=\"i\" access=\"read\"/>\n  <property name=\"Position\" type=\"i\" access=\"readwrite\"/>\n  <property name=\"Size\" type=\"i\" access=\"readwrite\"/>\n  <property name=\"PanelXid\" type=\"x\" access=\"read\"/>\n  <signal name=\"DestroyApplet\">\n    <arg name=\"uid\" type=\"s\"/>\n  </signal>\n  <signal name=\"DestroyNotify\">\n  </signal>\n  <signal name=\"PropertyChanged\">\n    <arg name=\"prop_name\" type=\"s\"/>\n    <arg name=\"value\" type=\"v\"/>\n  </signal>\n</interface>\n";
    dbus_connection_list_registered(connection, g_object_get_data((GObject*) self, "dbus_object_path"), &children);
    for (int i = 0; children[i]; i++) {
        xml_data = xml_data + "<node name=\"" + children[i] + "\"/>\n";
    }
    dbus_free_string_array(children);
    xml_data += "</node>\n";
    const char* str = xml_data.c_str();
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &str);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_awn_panel_dbus_interface_property_get(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter, reply_iter, subiter;
    if (strcmp(dbus_message_get_signature(message), "ss")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &reply_iter);

    const char* interface_name;
    dbus_message_iter_get_basic(&iter, &interface_name);
    dbus_message_iter_next(&iter);

    const char* property_name;
    dbus_message_iter_get_basic(&iter, &property_name);
    dbus_message_iter_next(&iter);

    if ((strcmp(interface_name, "org.awnproject.Awn.Panel") == 0) && (strcmp(property_name, "OffsetModifier") == 0)) {
        double result;
        dbus_message_iter_open_container(&reply_iter, DBUS_TYPE_VARIANT, "d", &subiter);
        result = awn_panel_dbus_interface_get_offset_modifier(self);
        dbus_message_iter_append_basic(&subiter, DBUS_TYPE_DOUBLE, &result);
        dbus_message_iter_close_container(&reply_iter, &subiter);
    } else if ((strcmp(interface_name, "org.awnproject.Awn.Panel") == 0) && (strcmp(property_name, "MaxSize") == 0)) {
        int result;
        dbus_int32_t _tmp3_;
        dbus_message_iter_open_container(&reply_iter, DBUS_TYPE_VARIANT, "i", &subiter);
        result = awn_panel_dbus_interface_get_max_size(self);
        _tmp3_ = result;
        dbus_message_iter_append_basic(&subiter, DBUS_TYPE_INT32, &_tmp3_);
        dbus_message_iter_close_container(&reply_iter, &subiter);
    } else if ((strcmp(interface_name, "org.awnproject.Awn.Panel") == 0) && (strcmp(property_name, "Offset") == 0)) {
        int result;
        dbus_int32_t _tmp4_;
        dbus_message_iter_open_container(&reply_iter, DBUS_TYPE_VARIANT, "i", &subiter);
        result = awn_panel_dbus_interface_get_offset(self);
        _tmp4_ = result;
        dbus_message_iter_append_basic(&subiter, DBUS_TYPE_INT32, &_tmp4_);
        dbus_message_iter_close_container(&reply_iter, &subiter);
    } else if ((strcmp(interface_name, "org.awnproject.Awn.Panel") == 0) && (strcmp(property_name, "PathType") == 0)) {
        int result;
        dbus_int32_t _tmp5_;
        dbus_message_iter_open_container(&reply_iter, DBUS_TYPE_VARIANT, "i", &subiter);
        result = awn_panel_dbus_interface_get_path_type(self);
        _tmp5_ = result;
        dbus_message_iter_append_basic(&subiter, DBUS_TYPE_INT32, &_tmp5_);
        dbus_message_iter_close_container(&reply_iter, &subiter);
    } else if ((strcmp(interface_name, "org.awnproject.Awn.Panel") == 0) && (strcmp(property_name, "Position") == 0)) {
        int result;
        dbus_int32_t _tmp6_;
        dbus_message_iter_open_container(&reply_iter, DBUS_TYPE_VARIANT, "i", &subiter);
        result = awn_panel_dbus_interface_get_position(self);
        _tmp6_ = result;
        dbus_message_iter_append_basic(&subiter, DBUS_TYPE_INT32, &_tmp6_);
        dbus_message_iter_close_container(&reply_iter, &subiter);
    } else if ((strcmp(interface_name, "org.awnproject.Awn.Panel") == 0) && (strcmp(property_name, "Size") == 0)) {
        int result;
        dbus_int32_t _tmp7_;
        dbus_message_iter_open_container(&reply_iter, DBUS_TYPE_VARIANT, "i", &subiter);
        result = awn_panel_dbus_interface_get_size(self);
        _tmp7_ = result;
        dbus_message_iter_append_basic(&subiter, DBUS_TYPE_INT32, &_tmp7_);
        dbus_message_iter_close_container(&reply_iter, &subiter);
    } else if ((strcmp(interface_name, "org.awnproject.Awn.Panel") == 0) && (strcmp(property_name, "PanelXid") == 0)) {
        int64_t result;
        dbus_int64_t _tmp8_;
        dbus_message_iter_open_container(&reply_iter, DBUS_TYPE_VARIANT, "x", &subiter);
        result = awn_panel_dbus_interface_get_panel_xid(self);
        _tmp8_ = result;
        dbus_message_iter_append_basic(&subiter, DBUS_TYPE_INT64, &_tmp8_);
        dbus_message_iter_close_container(&reply_iter, &subiter);
    } else {
        dbus_message_unref(reply);
        reply = NULL;
    }
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_awn_panel_dbus_interface_property_set(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter, subiter;

    if (strcmp(dbus_message_get_signature(message), "ssv")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }

    dbus_message_iter_init(message, &iter);
    DBusMessage* reply = dbus_message_new_method_return(message);

    const char* interface_name;
    dbus_message_iter_get_basic(&iter, &interface_name);
    dbus_message_iter_next(&iter);

    const char* property_name;
    dbus_message_iter_get_basic(&iter, &property_name);
    dbus_message_iter_next(&iter);
    dbus_message_iter_recurse(&iter, &subiter);

    if ((strcmp(interface_name, "org.awnproject.Awn.Panel") == 0) && (strcmp(property_name, "Offset") == 0)) {
        gint value;
        dbus_int32_t _tmp11_;
        dbus_message_iter_get_basic(&subiter, &_tmp11_);
        dbus_message_iter_next(&subiter);
        value = _tmp11_;
        awn_panel_dbus_interface_set_offset(self, value);
    } else if ((strcmp(interface_name, "org.awnproject.Awn.Panel") == 0) && (strcmp(property_name, "Position") == 0)) {
        gint value;
        dbus_int32_t _tmp12_;
        dbus_message_iter_get_basic(&subiter, &_tmp12_);
        dbus_message_iter_next(&subiter);
        value = _tmp12_;
        awn_panel_dbus_interface_set_position(self, value);
    } else if ((strcmp(interface_name, "org.awnproject.Awn.Panel") == 0) && (strcmp(property_name, "Size") == 0)) {
        gint value;
        dbus_int32_t _tmp13_;
        dbus_message_iter_get_basic(&subiter, &_tmp13_);
        dbus_message_iter_next(&subiter);
        value = _tmp13_;
        awn_panel_dbus_interface_set_size(self, value);
    } else {
        dbus_message_unref(reply);
        reply = NULL;
    }
    g_free(interface_name);
    g_free(property_name);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_awn_panel_dbus_interface_property_get_all(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter, reply_iter, subiter, entry_iter, value_iter;
    const char* property_name;
    if (strcmp(dbus_message_get_signature(message), "s")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }

    dbus_message_iter_init(message, &iter);
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &reply_iter);

    const char* interface_name;
    dbus_message_iter_get_basic(&iter, &interface_name);
    dbus_message_iter_next(&iter);

    if (strcmp(interface_name, "org.awnproject.Awn.Panel") == 0) {
        dbus_message_iter_open_container(&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
        {
            double result;
            dbus_message_iter_open_container(&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
            property_name = "OffsetModifier";
            dbus_message_iter_append_basic(&entry_iter, DBUS_TYPE_STRING, &property_name);
            dbus_message_iter_open_container(&entry_iter, DBUS_TYPE_VARIANT, "d", &value_iter);
            result = awn_panel_dbus_interface_get_offset_modifier(self);
            dbus_message_iter_append_basic(&value_iter, DBUS_TYPE_DOUBLE, &result);
            dbus_message_iter_close_container(&entry_iter, &value_iter);
            dbus_message_iter_close_container(&subiter, &entry_iter);
        }
        {
            dbus_int32_t result;
            dbus_message_iter_open_container(&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
            property_name = "MaxSize";
            dbus_message_iter_append_basic(&entry_iter, DBUS_TYPE_STRING, &property_name);
            dbus_message_iter_open_container(&entry_iter, DBUS_TYPE_VARIANT, "i", &value_iter);
            result = awn_panel_dbus_interface_get_max_size(self);
            dbus_message_iter_append_basic(&value_iter, DBUS_TYPE_INT32, &result);
            dbus_message_iter_close_container(&entry_iter, &value_iter);
            dbus_message_iter_close_container(&subiter, &entry_iter);
        }
        {
            gint result;
            dbus_int32_t _tmp17_;
            dbus_message_iter_open_container(&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
            property_name = "Offset";
            dbus_message_iter_append_basic(&entry_iter, DBUS_TYPE_STRING, &property_name);
            dbus_message_iter_open_container(&entry_iter, DBUS_TYPE_VARIANT, "i", &value_iter);
            result = awn_panel_dbus_interface_get_offset(self);
            dbus_message_iter_append_basic(&value_iter, DBUS_TYPE_INT32, &result);
            dbus_message_iter_close_container(&entry_iter, &value_iter);
            dbus_message_iter_close_container(&subiter, &entry_iter);
        }
        {
            dbus_int32_t result;
            dbus_message_iter_open_container(&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
            property_name = "PathType";
            dbus_message_iter_append_basic(&entry_iter, DBUS_TYPE_STRING, &property_name);
            dbus_message_iter_open_container(&entry_iter, DBUS_TYPE_VARIANT, "i", &value_iter);
            result = awn_panel_dbus_interface_get_path_type(self);
            dbus_message_iter_append_basic(&value_iter, DBUS_TYPE_INT32, &result);
            dbus_message_iter_close_container(&entry_iter, &value_iter);
            dbus_message_iter_close_container(&subiter, &entry_iter);
        }
        {
            dbus_int32_t result;
            dbus_message_iter_open_container(&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
            property_name = "Position";
            dbus_message_iter_append_basic(&entry_iter, DBUS_TYPE_STRING, &property_name);
            dbus_message_iter_open_container(&entry_iter, DBUS_TYPE_VARIANT, "i", &value_iter);
            result = awn_panel_dbus_interface_get_position(self);
            dbus_message_iter_append_basic(&value_iter, DBUS_TYPE_INT32, &result);
            dbus_message_iter_close_container(&entry_iter, &value_iter);
            dbus_message_iter_close_container(&subiter, &entry_iter);
        }
        {
            dbus_int32_t result;
            dbus_message_iter_open_container(&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
            property_name = "Size";
            dbus_message_iter_append_basic(&entry_iter, DBUS_TYPE_STRING, &property_name);
            dbus_message_iter_open_container(&entry_iter, DBUS_TYPE_VARIANT, "i", &value_iter);
            result = awn_panel_dbus_interface_get_size(self);
            dbus_message_iter_append_basic(&value_iter, DBUS_TYPE_INT32, &result);
            dbus_message_iter_close_container(&entry_iter, &value_iter);
            dbus_message_iter_close_container(&subiter, &entry_iter);
        }
        {
            dbus_int64_t result;
            dbus_message_iter_open_container(&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
            property_name = "PanelXid";
            dbus_message_iter_append_basic(&entry_iter, DBUS_TYPE_STRING, &property_name);
            dbus_message_iter_open_container(&entry_iter, DBUS_TYPE_VARIANT, "x", &value_iter);
            result = awn_panel_dbus_interface_get_panel_xid(self);
            dbus_message_iter_append_basic(&value_iter, DBUS_TYPE_INT64, &result);
            dbus_message_iter_close_container(&entry_iter, &value_iter);
            dbus_message_iter_close_container(&subiter, &entry_iter);
        }
        dbus_message_iter_close_container(&reply_iter, &subiter);
    } else {
        dbus_message_unref(reply);
        reply = NULL;
    }
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_awn_panel_dbus_interface_add_applet(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    GError* error = nullptr;

    if (strcmp(dbus_message_get_signature(message), "s")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }

    DBusMessageIter iter;
    dbus_message_iter_init(message, &iter);

    const char* desktop_file;
    dbus_message_iter_get_basic(&iter, &desktop_file);
    dbus_message_iter_next(&iter);

    awn_panel_dbus_interface_add_applet(self, desktop_file, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_awn_panel_dbus_interface_delete_applet(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    GError* error = nullptr;
    if (strcmp(dbus_message_get_signature(message), "s")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }

    DBusMessageIter iter;
    dbus_message_iter_init(message, &iter);

    const char* uid;
    dbus_message_iter_get_basic(&iter, &uid);
    dbus_message_iter_next(&iter);

    awn_panel_dbus_interface_delete_applet(self, uid, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }

    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_awn_panel_dbus_interface_docklet_request(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    GError* error = nullptr;

    if (strcmp(dbus_message_get_signature(message), "ibb")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }

    DBusMessageIter iter;
    dbus_message_iter_init(message, &iter);

    int min_size = 0;
    dbus_int32_t tmp32;
    dbus_message_iter_get_basic(&iter, &tmp32);
    dbus_message_iter_next(&iter);
    min_size = tmp32;

    gboolean shrink;
    dbus_message_iter_get_basic(&iter, &shrink);
    dbus_message_iter_next(&iter);

    gboolean expand;
    dbus_message_iter_get_basic(&iter, &expand);
    dbus_message_iter_next(&iter);

    gint64 result = awn_panel_dbus_interface_docklet_request(self, min_size, shrink, expand, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }

    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_INT64, &result);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_awn_panel_dbus_interface_get_inhibitors(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    GError* error = nullptr;
    gchar** result;
    int result_length1;
    gchar** _tmp28_;
    DBusMessageIter _tmp29_;

    if (strcmp(dbus_message_get_signature(message), "")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    result_length1 = 0;
    result = awn_panel_dbus_interface_get_inhibitors(self, &result_length1, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    _tmp28_ = result;
    dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, "s", &_tmp29_);
    for (int i = 0; i < result_length1; i++) {
        const char* _tmp31_;
        _tmp31_ = *_tmp28_;
        dbus_message_iter_append_basic(&_tmp29_, DBUS_TYPE_STRING, &_tmp31_);
        _tmp28_++;
    }
    dbus_message_iter_close_container(&iter, &_tmp29_);
    awn::vala_array_free(result, result_length1, (GDestroyNotify) g_free);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_awn_panel_dbus_interface_get_snapshot(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    GError* error = nullptr;
    AwnImageStruct result = {0};
    DBusMessageIter _tmp32_;
    dbus_int32_t _tmp33_;
    dbus_int32_t _tmp34_;
    dbus_int32_t _tmp35_;
    dbus_bool_t _tmp36_;
    dbus_int32_t _tmp37_;
    dbus_int32_t _tmp38_;
    gchar* _tmp39_;
    DBusMessageIter _tmp40_;
    int _tmp41_;
    if (strcmp(dbus_message_get_signature(message), "")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    awn_panel_dbus_interface_get_snapshot(self, &result, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    dbus_message_iter_open_container(&iter, DBUS_TYPE_STRUCT, NULL, &_tmp32_);
    _tmp33_ = result.width;
    dbus_message_iter_append_basic(&_tmp32_, DBUS_TYPE_INT32, &_tmp33_);
    _tmp34_ = result.height;
    dbus_message_iter_append_basic(&_tmp32_, DBUS_TYPE_INT32, &_tmp34_);
    _tmp35_ = result.rowstride;
    dbus_message_iter_append_basic(&_tmp32_, DBUS_TYPE_INT32, &_tmp35_);
    _tmp36_ = result.has_alpha;
    dbus_message_iter_append_basic(&_tmp32_, DBUS_TYPE_BOOLEAN, &_tmp36_);
    _tmp37_ = result.bits_per_sample;
    dbus_message_iter_append_basic(&_tmp32_, DBUS_TYPE_INT32, &_tmp37_);
    _tmp38_ = result.num_channels;
    dbus_message_iter_append_basic(&_tmp32_, DBUS_TYPE_INT32, &_tmp38_);
    _tmp39_ = result.pixel_data;
    dbus_message_iter_open_container(&_tmp32_, DBUS_TYPE_ARRAY, "y", &_tmp40_);
    for (_tmp41_ = 0; _tmp41_ < result.pixel_data_length1; _tmp41_++) {
        guint8 _tmp42_;
        _tmp42_ = *_tmp39_;
        dbus_message_iter_append_basic(&_tmp40_, DBUS_TYPE_BYTE, &_tmp42_);
        _tmp39_++;
    }
    dbus_message_iter_close_container(&_tmp32_, &_tmp40_);
    dbus_message_iter_close_container(&iter, &_tmp32_);
    awn_image_struct_destroy(& result);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_awn_panel_dbus_interface_inhibit_autohide(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    GError* error = nullptr;
    if (strcmp(dbus_message_get_signature(message), "ss")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    const char* app_name;
    dbus_message_iter_get_basic(&iter, &app_name);
    dbus_message_iter_next(&iter);
    const char* reason;
    dbus_message_iter_get_basic(&iter, &reason);
    dbus_message_iter_next(&iter);
    unsigned result = awn_panel_dbus_interface_inhibit_autohide(self, dbus_message_get_sender(message), app_name, reason, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    dbus_uint32_t _tmp45_ = result;
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &_tmp45_);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_awn_panel_dbus_interface_uninhibit_autohide(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    GError* error = nullptr;
    guint cookie = 0U;
    dbus_uint32_t _tmp46_;
    if (strcmp(dbus_message_get_signature(message), "u")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }

    DBusMessageIter iter;
    dbus_message_iter_init(message, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp46_);
    dbus_message_iter_next(&iter);
    cookie = _tmp46_;
    awn_panel_dbus_interface_uninhibit_autohide(self, cookie, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_awn_panel_dbus_interface_set_applet_flags(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    if (strcmp(dbus_message_get_signature(message), "si")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }

    DBusMessageIter iter;
    dbus_message_iter_init(message, &iter);

    const char* uid;
    dbus_message_iter_get_basic(&iter, &uid);
    dbus_message_iter_next(&iter);

    dbus_int32_t flags;
    dbus_message_iter_get_basic(&iter, &flags);
    dbus_message_iter_next(&iter);

    GError* error = nullptr;
    awn_panel_dbus_interface_set_applet_flags(self, uid, flags, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static DBusHandlerResult _dbus_awn_panel_dbus_interface_set_glow(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    GError* error = nullptr;
    gboolean activate = FALSE;
    dbus_bool_t _tmp49_;
    if (strcmp(dbus_message_get_signature(message), "b")) {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
    dbus_message_iter_init(message, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp49_);
    dbus_message_iter_next(&iter);
    activate = _tmp49_;
    awn_panel_dbus_interface_set_glow(self, dbus_message_get_sender(message), activate, &error);
    if (error) {
        awn::vala_send_dbus_error_message(connection, message, error);
        return DBUS_HANDLER_RESULT_HANDLED;
    }
    DBusMessage* reply = dbus_message_new_method_return(message);
    dbus_message_iter_init_append(reply, &iter);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


DBusHandlerResult awn_panel_dbus_interface_dbus_message(DBusConnection* connection, DBusMessage* message, void* object)
{
    DBusHandlerResult result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    if (dbus_message_is_method_call(message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
        result = _dbus_awn_panel_dbus_interface_introspect(object, connection, message);
    } else if (dbus_message_is_method_call(message, "org.freedesktop.DBus.Properties", "Get")) {
        result = _dbus_awn_panel_dbus_interface_property_get(object, connection, message);
    } else if (dbus_message_is_method_call(message, "org.freedesktop.DBus.Properties", "Set")) {
        result = _dbus_awn_panel_dbus_interface_property_set(object, connection, message);
    } else if (dbus_message_is_method_call(message, "org.freedesktop.DBus.Properties", "GetAll")) {
        result = _dbus_awn_panel_dbus_interface_property_get_all(object, connection, message);
    } else if (dbus_message_is_method_call(message, "org.awnproject.Awn.Panel", "AddApplet")) {
        result = _dbus_awn_panel_dbus_interface_add_applet(object, connection, message);
    } else if (dbus_message_is_method_call(message, "org.awnproject.Awn.Panel", "DeleteApplet")) {
        result = _dbus_awn_panel_dbus_interface_delete_applet(object, connection, message);
    } else if (dbus_message_is_method_call(message, "org.awnproject.Awn.Panel", "DockletRequest")) {
        result = _dbus_awn_panel_dbus_interface_docklet_request(object, connection, message);
    } else if (dbus_message_is_method_call(message, "org.awnproject.Awn.Panel", "GetInhibitors")) {
        result = _dbus_awn_panel_dbus_interface_get_inhibitors(object, connection, message);
    } else if (dbus_message_is_method_call(message, "org.awnproject.Awn.Panel", "GetSnapshot")) {
        result = _dbus_awn_panel_dbus_interface_get_snapshot(object, connection, message);
    } else if (dbus_message_is_method_call(message, "org.awnproject.Awn.Panel", "InhibitAutohide")) {
        result = _dbus_awn_panel_dbus_interface_inhibit_autohide(object, connection, message);
    } else if (dbus_message_is_method_call(message, "org.awnproject.Awn.Panel", "UninhibitAutohide")) {
        result = _dbus_awn_panel_dbus_interface_uninhibit_autohide(object, connection, message);
    } else if (dbus_message_is_method_call(message, "org.awnproject.Awn.Panel", "SetAppletFlags")) {
        result = _dbus_awn_panel_dbus_interface_set_applet_flags(object, connection, message);
    } else if (dbus_message_is_method_call(message, "org.awnproject.Awn.Panel", "SetGlow")) {
        result = _dbus_awn_panel_dbus_interface_set_glow(object, connection, message);
    }
    if (result == DBUS_HANDLER_RESULT_HANDLED) {
        return result;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


static void _dbus_awn_panel_dbus_interface_destroy_applet(GObject* _sender, const gchar* uid, DBusConnection* _connection)
{
    DBusMessageIter iter;
    const char* path = g_object_get_data(_sender, "dbus_object_path");
    DBusMessage* msg = dbus_message_new_signal(path, "org.awnproject.Awn.Panel", "DestroyApplet");
    dbus_message_iter_init_append(msg, &iter);
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &uid);
    dbus_connection_send(_connection, msg, NULL);
    dbus_message_unref(msg);
}


static void _dbus_awn_panel_dbus_interface_destroy_notify(GObject* _sender, DBusConnection* _connection)
{
    DBusMessageIter iter;
    const char* path = g_object_get_data(_sender, "dbus_object_path");
    DBusMessage* msg = dbus_message_new_signal(path, "org.awnproject.Awn.Panel", "DestroyNotify");
    dbus_message_iter_init_append(msg, &iter);
    dbus_connection_send(_connection, msg, NULL);
    dbus_message_unref(msg);
}


static void _dbus_awn_panel_dbus_interface_property_changed(GObject* _sender, const gchar* prop_name, GValue* value, DBusConnection* _connection)
{
    DBusMessageIter iter;
    DBusMessageIter _tmp52_;

    const char* _path = g_object_get_data(_sender, "dbus_object_path");
    DBusMessage* msg = dbus_message_new_signal(_path, "org.awnproject.Awn.Panel", "PropertyChanged");

    dbus_message_iter_init_append(msg, &iter);
    const char* _tmp51_ = prop_name;
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp51_);
    if (G_VALUE_TYPE(value) == G_TYPE_UCHAR) {
        guint8 _tmp53_;
        dbus_message_iter_open_container(&iter, DBUS_TYPE_VARIANT, "y", &_tmp52_);
        _tmp53_ = g_value_get_uchar(value);
        dbus_message_iter_append_basic(&_tmp52_, DBUS_TYPE_BYTE, &_tmp53_);
        dbus_message_iter_close_container(&iter, &_tmp52_);
    } else if (G_VALUE_TYPE(value) == G_TYPE_BOOLEAN) {
        dbus_bool_t _tmp54_;
        dbus_message_iter_open_container(&iter, DBUS_TYPE_VARIANT, "b", &_tmp52_);
        _tmp54_ = g_value_get_boolean(value);
        dbus_message_iter_append_basic(&_tmp52_, DBUS_TYPE_BOOLEAN, &_tmp54_);
        dbus_message_iter_close_container(&iter, &_tmp52_);
    } else if (G_VALUE_TYPE(value) == G_TYPE_INT) {
        dbus_int32_t _tmp55_;
        dbus_message_iter_open_container(&iter, DBUS_TYPE_VARIANT, "i", &_tmp52_);
        _tmp55_ = g_value_get_int(value);
        dbus_message_iter_append_basic(&_tmp52_, DBUS_TYPE_INT32, &_tmp55_);
        dbus_message_iter_close_container(&iter, &_tmp52_);
    } else if (G_VALUE_TYPE(value) == G_TYPE_UINT) {
        dbus_uint32_t _tmp56_;
        dbus_message_iter_open_container(&iter, DBUS_TYPE_VARIANT, "u", &_tmp52_);
        _tmp56_ = g_value_get_uint(value);
        dbus_message_iter_append_basic(&_tmp52_, DBUS_TYPE_UINT32, &_tmp56_);
        dbus_message_iter_close_container(&iter, &_tmp52_);
    } else if (G_VALUE_TYPE(value) == G_TYPE_INT64) {
        dbus_int64_t _tmp57_;
        dbus_message_iter_open_container(&iter, DBUS_TYPE_VARIANT, "x", &_tmp52_);
        _tmp57_ = g_value_get_int64(value);
        dbus_message_iter_append_basic(&_tmp52_, DBUS_TYPE_INT64, &_tmp57_);
        dbus_message_iter_close_container(&iter, &_tmp52_);
    } else if (G_VALUE_TYPE(value) == G_TYPE_UINT64) {
        dbus_uint64_t _tmp58_;
        dbus_message_iter_open_container(&iter, DBUS_TYPE_VARIANT, "t", &_tmp52_);
        _tmp58_ = g_value_get_uint64(value);
        dbus_message_iter_append_basic(&_tmp52_, DBUS_TYPE_UINT64, &_tmp58_);
        dbus_message_iter_close_container(&iter, &_tmp52_);
    } else if (G_VALUE_TYPE(value) == G_TYPE_DOUBLE) {
        double _tmp59_;
        dbus_message_iter_open_container(&iter, DBUS_TYPE_VARIANT, "d", &_tmp52_);
        _tmp59_ = g_value_get_double(value);
        dbus_message_iter_append_basic(&_tmp52_, DBUS_TYPE_DOUBLE, &_tmp59_);
        dbus_message_iter_close_container(&iter, &_tmp52_);
    } else if (G_VALUE_TYPE(value) == G_TYPE_STRING) {
        const char* _tmp60_;
        dbus_message_iter_open_container(&iter, DBUS_TYPE_VARIANT, "s", &_tmp52_);
        _tmp60_ = g_value_get_string(value);
        dbus_message_iter_append_basic(&_tmp52_, DBUS_TYPE_STRING, &_tmp60_);
        dbus_message_iter_close_container(&iter, &_tmp52_);
    } else if (G_VALUE_TYPE(value) == G_TYPE_STRV) {
        const gchar** _tmp61_;
        DBusMessageIter _tmp62_;
        unsigned int _tmp63_;
        dbus_message_iter_open_container(&iter, DBUS_TYPE_VARIANT, "as", &_tmp52_);
        _tmp61_ = g_value_get_boxed(value);
        dbus_message_iter_open_container(&_tmp52_, DBUS_TYPE_ARRAY, "s", &_tmp62_);
        for (_tmp63_ = 0; _tmp63_ < g_strv_length(g_value_get_boxed(value)); _tmp63_++) {
            const char* _tmp64_;
            _tmp64_ = *_tmp61_;
            dbus_message_iter_append_basic(&_tmp62_, DBUS_TYPE_STRING, &_tmp64_);
            _tmp61_++;
        }
        dbus_message_iter_close_container(&_tmp52_, &_tmp62_);
        dbus_message_iter_close_container(&iter, &_tmp52_);
    }
    dbus_connection_send(_connection, msg, NULL);
    dbus_message_unref(msg);
}


void awn_panel_dbus_interface_dbus_register_object(DBusConnection* connection, const char* path, void* object)
{
    if (!g_object_get_data(object, "dbus_object_path")) {
        g_object_set_data(object, "dbus_object_path", g_strdup(path));
        dbus_connection_register_object_path(connection, path, &_awn_panel_dbus_interface_dbus_path_vtable, object);
        g_object_weak_ref(object, _vala_dbus_unregister_object, connection);
    }
    g_signal_connect(object, "destroy-applet", (GCallback) _dbus_awn_panel_dbus_interface_destroy_applet, connection);
    g_signal_connect(object, "destroy-notify", (GCallback) _dbus_awn_panel_dbus_interface_destroy_notify, connection);
    g_signal_connect(object, "property-changed", (GCallback) _dbus_awn_panel_dbus_interface_property_changed, connection);
}


GType awn_panel_dbus_interface_get_type(void)
{
    static volatile gsize type_id = 0;
    if (g_once_init_enter(&type_id)) {
        static const GTypeInfo g_define_type_info = { sizeof(AwnPanelDBusInterfaceIface), (GBaseInitFunc) awn_panel_dbus_interface_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
        GType awn_panel_dbus_interface_type_id;
        awn_panel_dbus_interface_type_id = g_type_register_static(G_TYPE_INTERFACE, "AwnPanelDBusInterface", &g_define_type_info, 0);
        g_type_interface_add_prerequisite(awn_panel_dbus_interface_type_id, G_TYPE_OBJECT);
        g_type_set_qdata(awn_panel_dbus_interface_type_id, g_quark_from_string("ValaDBusInterfaceProxyType"), &awn_panel_dbus_interface_dbus_proxy_get_type);
        g_type_set_qdata(awn_panel_dbus_interface_type_id, g_quark_from_static_string("DBusObjectVTable"), (void*)(&_awn_panel_dbus_interface_dbus_vtable));
        g_once_init_leave(&type_id, awn_panel_dbus_interface_type_id);
    }
    return type_id;
}

extern "C" {
    G_DEFINE_TYPE_EXTENDED(AwnPanelDBusInterfaceDBusProxy, awn_panel_dbus_interface_dbus_proxy, DBUS_TYPE_G_PROXY, 0, G_IMPLEMENT_INTERFACE(AWN_TYPE_PANEL_DBUS_INTERFACE, awn_panel_dbus_interface_dbus_proxy_awn_panel_dbus_interface__interface_init));
}
AwnPanelDBusInterface* awn_panel_dbus_interface_dbus_proxy_new(DBusGConnection* connection, const char* name, const char* path)
{
    AwnPanelDBusInterface* self;
    self = g_object_new(awn_panel_dbus_interface_dbus_proxy_get_type(), "connection", connection, "name", name, "path", path, "interface", "org.awnproject.Awn.Panel", NULL);
    return self;
}


static GObject* awn_panel_dbus_interface_dbus_proxy_construct(GType gtype, guint n_properties, GObjectConstructParam* properties)
{
    GObject* self;
    DBusGConnection* connection;
    char* path;
    char* filter;
    self = G_OBJECT_CLASS(awn_panel_dbus_interface_dbus_proxy_parent_class)->constructor(gtype, n_properties, properties);
    g_object_get(self, "connection", &connection, NULL);
    g_object_get(self, "path", &path, NULL);
    dbus_connection_add_filter(dbus_g_connection_get_connection(connection), awn_panel_dbus_interface_dbus_proxy_filter, self, NULL);
    filter = g_strdup_printf("type='signal',path='%s',interface='org.awnproject.Awn.Panel'", path);
    dbus_bus_add_match(dbus_g_connection_get_connection(connection), filter, NULL);
    dbus_g_connection_unref(connection);
    g_free(path);
    g_free(filter);
    return self;
}


static void _dbus_handle_awn_panel_dbus_interface_destroy_applet(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    gchar* uid = NULL;
    const char* _tmp0_;
    if (strcmp(dbus_message_get_signature(message), "s")) {
        return;
    }
    dbus_message_iter_init(message, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp0_);
    dbus_message_iter_next(&iter);
    uid = g_strdup(_tmp0_);
    g_signal_emit_by_name(self, "destroy-applet", uid);
    g_free(uid);
}


static void _dbus_handle_awn_panel_dbus_interface_destroy_notify(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    if (strcmp(dbus_message_get_signature(message), "")) {
        return;
    }
    dbus_message_iter_init(message, &iter);
    g_signal_emit_by_name(self, "destroy-notify");
}


static void _dbus_handle_awn_panel_dbus_interface_property_changed(AwnPanelDBusInterface* self, DBusConnection* connection, DBusMessage* message)
{
    DBusMessageIter iter;
    gchar* prop_name = NULL;
    const char* _tmp1_;
    GValue value = {0};
    if (strcmp(dbus_message_get_signature(message), "sv")) {
        return;
    }
    dbus_message_iter_init(message, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp1_);
    dbus_message_iter_next(&iter);
    prop_name = g_strdup(_tmp1_);

    GValue _tmp2_ = {0};
    awn::vala_dbus_get_gvalue(&iter, &_tmp2_);
    dbus_message_iter_next(&iter);

    value = _tmp2_;
    g_signal_emit_by_name(self, "property-changed", prop_name, &value);
    _g_free0(prop_name);
    G_IS_VALUE(&value) ? (g_value_unset(&value), NULL) : NULL;
}


DBusHandlerResult awn_panel_dbus_interface_dbus_proxy_filter(DBusConnection* connection, DBusMessage* message, void* user_data)
{
    if (dbus_message_has_path(message, dbus_g_proxy_get_path(user_data))) {
        if (dbus_message_is_signal(message, "org.awnproject.Awn.Panel", "DestroyApplet")) {
            _dbus_handle_awn_panel_dbus_interface_destroy_applet(user_data, connection, message);
        } else if (dbus_message_is_signal(message, "org.awnproject.Awn.Panel", "DestroyNotify")) {
            _dbus_handle_awn_panel_dbus_interface_destroy_notify(user_data, connection, message);
        } else if (dbus_message_is_signal(message, "org.awnproject.Awn.Panel", "PropertyChanged")) {
            _dbus_handle_awn_panel_dbus_interface_property_changed(user_data, connection, message);
        }
    }
    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}


static void awn_panel_dbus_interface_dbus_proxy_dispose(GObject* self)
{
    DBusGConnection* connection;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        return;
    }
    ((AwnPanelDBusInterfaceDBusProxy*) self)->disposed = TRUE;
    g_object_get(self, "connection", &connection, NULL);
    dbus_connection_remove_filter(dbus_g_connection_get_connection(connection), awn_panel_dbus_interface_dbus_proxy_filter, self);
    G_OBJECT_CLASS(awn_panel_dbus_interface_dbus_proxy_parent_class)->dispose(self);
}


static void awn_panel_dbus_interface_dbus_proxy_class_init(AwnPanelDBusInterfaceDBusProxyClass* klass)
{
    G_OBJECT_CLASS(klass)->constructor = awn_panel_dbus_interface_dbus_proxy_construct;
    G_OBJECT_CLASS(klass)->dispose = awn_panel_dbus_interface_dbus_proxy_dispose;
    G_OBJECT_CLASS(klass)->get_property = _vala_awn_panel_dbus_interface_dbus_proxy_get_property;
    G_OBJECT_CLASS(klass)->set_property = _vala_awn_panel_dbus_interface_dbus_proxy_set_property;
}


static void awn_panel_dbus_interface_dbus_proxy_init(AwnPanelDBusInterfaceDBusProxy* self)
{
}


static void awn_panel_dbus_interface_dbus_proxy_add_applet(AwnPanelDBusInterface* self, const gchar* desktop_file, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessage* msg, *reply;
    DBusMessageIter iter;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return;
    }
    msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.awnproject.Awn.Panel", "AddApplet");
    dbus_message_iter_init_append(msg, &iter);
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &desktop_file);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);

        dbus_error_free(&_dbus_error);
        return;
    }
    if (strcmp(dbus_message_get_signature(reply), "")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_unref(reply);
}


static void awn_panel_dbus_interface_dbus_proxy_delete_applet(AwnPanelDBusInterface* self, const gchar* uid, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessage* msg, *reply;
    DBusMessageIter iter;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return;
    }
    msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.awnproject.Awn.Panel", "DeleteApplet");
    dbus_message_iter_init_append(msg, &iter);
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &uid);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);

        dbus_error_free(&_dbus_error);
        return;
    }
    if (strcmp(dbus_message_get_signature(reply), "")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_unref(reply);
}


static gint64 awn_panel_dbus_interface_dbus_proxy_docklet_request(AwnPanelDBusInterface* self, gint min_size, gboolean shrink, gboolean expand, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessage* msg, *reply;
    DBusMessageIter iter;
    dbus_int32_t _tmp23_;
    dbus_bool_t _tmp24_;
    dbus_bool_t _tmp25_;
    gint64 _result;
    dbus_int64_t _tmp26_;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return 0LL;
    }
    msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.awnproject.Awn.Panel", "DockletRequest");
    dbus_message_iter_init_append(msg, &iter);
    _tmp23_ = min_size;
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_INT32, &_tmp23_);
    _tmp24_ = shrink;
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_BOOLEAN, &_tmp24_);
    _tmp25_ = expand;
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_BOOLEAN, &_tmp25_);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);

        dbus_error_free(&_dbus_error);
        return 0;
    }
    if (strcmp(dbus_message_get_signature(reply), "x")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "x", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return 0LL;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp26_);
    dbus_message_iter_next(&iter);
    _result = _tmp26_;
    dbus_message_unref(reply);
    return _result;
}


static gchar** awn_panel_dbus_interface_dbus_proxy_get_inhibitors(AwnPanelDBusInterface* self, int* result_length1, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessage* msg, *reply;
    DBusMessageIter iter;
    gchar** _result;
    int _result_length1;
    gchar** _tmp28_;
    int _tmp28__length;
    int _tmp28__size;
    int _tmp28__length1;
    DBusMessageIter _tmp29_;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return NULL;
    }
    msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.awnproject.Awn.Panel", "GetInhibitors");
    dbus_message_iter_init_append(msg, &iter);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);

        dbus_error_free(&_dbus_error);
        return nullptr;
    }
    if (strcmp(dbus_message_get_signature(reply), "as")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "as", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return NULL;
    }
    dbus_message_iter_init(reply, &iter);
    _result_length1 = 0;
    _tmp28_ = g_new(gchar*, 5);
    _tmp28__length = 0;
    _tmp28__size = 4;
    _tmp28__length1 = 0;
    dbus_message_iter_recurse(&iter, &_tmp29_);
    for (; dbus_message_iter_get_arg_type(&_tmp29_); _tmp28__length1++) {
        const char* _tmp30_;
        if (_tmp28__size == _tmp28__length) {
            _tmp28__size = 2 * _tmp28__size;
            _tmp28_ = g_renew(gchar*, _tmp28_, _tmp28__size + 1);
        }
        dbus_message_iter_get_basic(&_tmp29_, &_tmp30_);
        dbus_message_iter_next(&_tmp29_);
        _tmp28_[_tmp28__length++] = g_strdup(_tmp30_);
    }
    _result_length1 = _tmp28__length1;
    _tmp28_[_tmp28__length] = NULL;
    dbus_message_iter_next(&iter);
    _result = _tmp28_;
    *result_length1 = _result_length1;
    dbus_message_unref(reply);
    return _result;
}


static void awn_panel_dbus_interface_dbus_proxy_get_snapshot(AwnPanelDBusInterface* self, AwnImageStruct* result, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessage* msg, *reply;
    DBusMessageIter iter;
    AwnImageStruct _tmp32_;
    dbus_int32_t _tmp34_;
    dbus_int32_t _tmp35_;
    dbus_int32_t _tmp36_;
    dbus_bool_t _tmp37_;
    dbus_int32_t _tmp38_;
    dbus_int32_t _tmp39_;
    gchar* _tmp40_;
    int _tmp40__length;
    int _tmp40__size;
    int _tmp40__length1;
    DBusMessageIter _tmp41_;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return;
    }
    msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.awnproject.Awn.Panel", "GetSnapshot");
    dbus_message_iter_init_append(msg, &iter);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);

        dbus_error_free(&_dbus_error);
        return;
    }
    if (strcmp(dbus_message_get_signature(reply), "(iiibiiay)")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "(iiibiiay)", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return;
    }
    dbus_message_iter_init(reply, &iter);

    DBusMessageIter subiter;
    dbus_message_iter_recurse(&iter, &subiter);
    dbus_message_iter_get_basic(&subiter, &_tmp34_);
    dbus_message_iter_next(&subiter);
    _tmp32_.width = _tmp34_;
    dbus_message_iter_get_basic(&subiter, &_tmp35_);
    dbus_message_iter_next(&subiter);
    _tmp32_.height = _tmp35_;
    dbus_message_iter_get_basic(&subiter, &_tmp36_);
    dbus_message_iter_next(&subiter);
    _tmp32_.rowstride = _tmp36_;
    dbus_message_iter_get_basic(&subiter, &_tmp37_);
    dbus_message_iter_next(&subiter);
    _tmp32_.has_alpha = _tmp37_;
    dbus_message_iter_get_basic(&subiter, &_tmp38_);
    dbus_message_iter_next(&subiter);
    _tmp32_.bits_per_sample = _tmp38_;
    dbus_message_iter_get_basic(&subiter, &_tmp39_);
    dbus_message_iter_next(&subiter);
    _tmp32_.num_channels = _tmp39_;
    _tmp40_ = g_new(gchar, 5);
    _tmp40__length = 0;
    _tmp40__size = 4;
    _tmp40__length1 = 0;
    dbus_message_iter_recurse(&subiter, &_tmp41_);
    for (; dbus_message_iter_get_arg_type(&_tmp41_); _tmp40__length1++) {
        guint8 _tmp42_;
        if (_tmp40__size == _tmp40__length) {
            _tmp40__size = 2 * _tmp40__size;
            _tmp40_ = g_renew(gchar, _tmp40_, _tmp40__size + 1);
        }
        dbus_message_iter_get_basic(&_tmp41_, &_tmp42_);
        dbus_message_iter_next(&_tmp41_);
        _tmp40_[_tmp40__length++] = _tmp42_;
    }
    _tmp32_.pixel_data_length1 = _tmp40__length1;
    dbus_message_iter_next(&subiter);
    _tmp32_.pixel_data = _tmp40_;
    dbus_message_iter_next(&iter);
    *result = _tmp32_;
    dbus_message_unref(reply);
}


static guint awn_panel_dbus_interface_dbus_proxy_inhibit_autohide(AwnPanelDBusInterface* self, const char* sender, const gchar* app_name, const gchar* reason, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessage* msg, *reply;
    DBusMessageIter iter;
    guint _result;
    dbus_uint32_t _tmp46_;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return 0U;
    }
    msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.awnproject.Awn.Panel", "InhibitAutohide");
    dbus_message_iter_init_append(msg, &iter);
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &app_name);
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &reason);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);
        dbus_error_free(&_dbus_error);
        return 0u;
    }
    if (strcmp(dbus_message_get_signature(reply), "u")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "u", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return 0U;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_iter_get_basic(&iter, &_tmp46_);
    dbus_message_iter_next(&iter);
    _result = _tmp46_;
    dbus_message_unref(reply);
    return _result;
}


static void awn_panel_dbus_interface_dbus_proxy_uninhibit_autohide(AwnPanelDBusInterface* self, guint cookie, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessage* msg, *reply;
    DBusMessageIter iter;
    dbus_uint32_t _tmp48_;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return;
    }
    msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.awnproject.Awn.Panel", "UninhibitAutohide");
    dbus_message_iter_init_append(msg, &iter);
    _tmp48_ = cookie;
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &_tmp48_);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);
        dbus_error_free(&_dbus_error);
        return;
    }
    if (strcmp(dbus_message_get_signature(reply), "")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_unref(reply);
}


static void awn_panel_dbus_interface_dbus_proxy_set_applet_flags(AwnPanelDBusInterface* self, const gchar* uid, gint flags, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessage* msg, *reply;
    DBusMessageIter iter;
    const char* _tmp50_;
    dbus_int32_t _tmp51_;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return;
    }
    msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.awnproject.Awn.Panel", "SetAppletFlags");
    dbus_message_iter_init_append(msg, &iter);
    _tmp50_ = uid;
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp50_);
    _tmp51_ = flags;
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_INT32, &_tmp51_);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);

        dbus_error_free(&_dbus_error);
        return;
    }
    if (strcmp(dbus_message_get_signature(reply), "")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_unref(reply);
}


static void awn_panel_dbus_interface_dbus_proxy_set_glow(AwnPanelDBusInterface* self, const char* sender, gboolean activate, GError** error)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessage* msg;
    DBusMessageIter iter;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
        return;
    }
    msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.awnproject.Awn.Panel", "SetGlow");
    dbus_message_iter_init_append(msg, &iter);

    dbus_bool_t tmp_bool = activate;
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_BOOLEAN, &tmp_bool);

    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);

    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        awn::vala_set_dbus_error(_dbus_error, error);
        dbus_error_free(&_dbus_error);
        return;
    }
    if (strcmp(dbus_message_get_signature(reply), "")) {
        g_set_error(error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_unref(reply);
}


static gdouble awn_panel_dbus_interface_dbus_proxy_get_offset_modifier(AwnPanelDBusInterface* self)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter iter, subiter;
    const char* _tmp55_;
    const char* _tmp56_;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        return 0.0;
    }
    DBusMessage* msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
    dbus_message_iter_init_append(msg, &iter);
    _tmp55_ = "org.awnproject.Awn.Panel";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp55_);
    _tmp56_ = "OffsetModifier";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp56_);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        g_critical("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
        dbus_error_free(&_dbus_error);
        return 0.0;
    }
    if (strcmp(dbus_message_get_signature(reply), "v")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return 0.0;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_iter_recurse(&iter, &subiter);
    if (strcmp(dbus_message_iter_get_signature(&subiter), "d")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "d", dbus_message_iter_get_signature(&subiter));
        dbus_message_unref(reply);
        return 0.0;
    }
    double result;
    dbus_message_iter_get_basic(&subiter, &result);
    dbus_message_iter_next(&subiter);
    dbus_message_unref(reply);
    return result;
}


static gint awn_panel_dbus_interface_dbus_proxy_get_max_size(AwnPanelDBusInterface* self)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter iter, subiter;
    const char* _tmp58_;
    const char* _tmp59_;
    gint _result;
    dbus_int32_t _tmp60_;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        return 0;
    }
    DBusMessage* msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
    dbus_message_iter_init_append(msg, &iter);
    _tmp58_ = "org.awnproject.Awn.Panel";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp58_);
    _tmp59_ = "MaxSize";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp59_);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        g_critical("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
        dbus_error_free(&_dbus_error);
        return 0;
    }
    if (strcmp(dbus_message_get_signature(reply), "v")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return 0;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_iter_recurse(&iter, &subiter);
    if (strcmp(dbus_message_iter_get_signature(&subiter), "i")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "i", dbus_message_iter_get_signature(&subiter));
        dbus_message_unref(reply);
        return 0;
    }
    dbus_message_iter_get_basic(&subiter, &_tmp60_);
    dbus_message_iter_next(&subiter);
    _result = _tmp60_;
    dbus_message_unref(reply);
    return _result;
}


static gint awn_panel_dbus_interface_dbus_proxy_get_offset(AwnPanelDBusInterface* self)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter iter, subiter;
    const char* _tmp61_;
    const char* _tmp62_;
    gint _result;
    dbus_int32_t _tmp63_;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        return 0;
    }
    DBusMessage* msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
    dbus_message_iter_init_append(msg, &iter);
    _tmp61_ = "org.awnproject.Awn.Panel";
    dbus_message_iter_append_basic(&_iter, DBUS_TYPE_STRING, &_tmp61_);
    _tmp62_ = "Offset";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp62_);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        g_critical("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
        dbus_error_free(&_dbus_error);
        return 0;
    }
    if (strcmp(dbus_message_get_signature(reply), "v")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return 0;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_iter_recurse(&iter, &subiter);
    if (strcmp(dbus_message_iter_get_signature(&subiter), "i")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "i", dbus_message_iter_get_signature(&subiter));
        dbus_message_unref(reply);
        return 0;
    }
    dbus_message_iter_get_basic(&subiter, &_tmp63_);
    dbus_message_iter_next(&subiter);
    _result = _tmp63_;
    dbus_message_unref(reply);
    return _result;
}


static void awn_panel_dbus_interface_dbus_proxy_set_offset(AwnPanelDBusInterface* self, gint value)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter iter, subiter;
    const char* _tmp64_;
    const char* _tmp65_;
    dbus_int32_t _tmp66_;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        return;
    }
    DBusMessage* msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
    dbus_message_iter_init_append(msg, &iter);
    _tmp64_ = "org.awnproject.Awn.Panel";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp64_);
    _tmp65_ = "Offset";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp65_);
    dbus_message_iter_open_container(&iter, DBUS_TYPE_VARIANT, "i", &subiter);
    _tmp66_ = value;
    dbus_message_iter_append_basic(&subiter, DBUS_TYPE_INT32, &_tmp66_);
    dbus_message_iter_close_container(&iter, &subiter);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        g_critical("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
        dbus_error_free(&_dbus_error);
        return;
    }
    if (strcmp(dbus_message_get_signature(reply), "")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_unref(reply);
}


static gint awn_panel_dbus_interface_dbus_proxy_get_path_type(AwnPanelDBusInterface* self)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter iter, subiter;
    const char* _tmp67_;
    const char* _tmp68_;
    gint _result;
    dbus_int32_t _tmp69_;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        return 0;
    }
    DBusMessage* msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
    dbus_message_iter_init_append(msg, &iter);
    _tmp67_ = "org.awnproject.Awn.Panel";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp67_);
    _tmp68_ = "PathType";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp68_);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        g_critical("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
        dbus_error_free(&_dbus_error);
        return 0;
    }
    if (strcmp(dbus_message_get_signature(reply), "v")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return 0;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_iter_recurse(&iter, &subiter);
    if (strcmp(dbus_message_iter_get_signature(&subiter), "i")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "i", dbus_message_iter_get_signature(&subiter));
        dbus_message_unref(reply);
        return 0;
    }
    dbus_message_iter_get_basic(&subiter, &_tmp69_);
    dbus_message_iter_next(&subiter);
    _result = _tmp69_;
    dbus_message_unref(reply);
    return _result;
}


static gint awn_panel_dbus_interface_dbus_proxy_get_position(AwnPanelDBusInterface* self)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter iter, subiter;
    const char* _tmp70_;
    const char* _tmp71_;
    gint _result;
    dbus_int32_t _tmp72_;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        return 0;
    }
    DBusMessage* msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
    dbus_message_iter_init_append(msg, &iter);
    _tmp70_ = "org.awnproject.Awn.Panel";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp70_);
    _tmp71_ = "Position";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp71_);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        g_critical("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
        dbus_error_free(&_dbus_error);
        return 0;
    }
    if (strcmp(dbus_message_get_signature(reply), "v")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return 0;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_iter_recurse(&iter, &subiter);
    if (strcmp(dbus_message_iter_get_signature(&subiter), "i")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "i", dbus_message_iter_get_signature(&subiter));
        dbus_message_unref(reply);
        return 0;
    }
    dbus_message_iter_get_basic(&subiter, &_tmp72_);
    dbus_message_iter_next(&subiter);
    _result = _tmp72_;
    dbus_message_unref(reply);
    return _result;
}


static void awn_panel_dbus_interface_dbus_proxy_set_position(AwnPanelDBusInterface* self, gint value)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter iter, subiter;
    const char* _tmp73_;
    const char* _tmp74_;
    dbus_int32_t _tmp75_;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        return;
    }
    DBusMessage* msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
    dbus_message_iter_init_append(msg, &iter);
    _tmp73_ = "org.awnproject.Awn.Panel";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp73_);
    _tmp74_ = "Position";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp74_);
    dbus_message_iter_open_container(&iter, DBUS_TYPE_VARIANT, "i", &subiter);
    _tmp75_ = value;
    dbus_message_iter_append_basic(&subiter, DBUS_TYPE_INT32, &_tmp75_);
    dbus_message_iter_close_container(&iter, &subiter);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        g_critical("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
        dbus_error_free(&_dbus_error);
        return;
    }
    if (strcmp(dbus_message_get_signature(reply), "")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_unref(reply);
}


static gint awn_panel_dbus_interface_dbus_proxy_get_size(AwnPanelDBusInterface* self)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter iter, subiter;
    const char* _tmp76_;
    const char* _tmp77_;
    gint _result;
    dbus_int32_t _tmp78_;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        return 0;
    }
    DBusMessage* msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
    dbus_message_iter_init_append(msg, &iter);
    _tmp76_ = "org.awnproject.Awn.Panel";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp76_);
    _tmp77_ = "Size";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp77_);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        g_critical("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
        dbus_error_free(&_dbus_error);
        return 0;
    }
    if (strcmp(dbus_message_get_signature(reply), "v")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return 0;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_iter_recurse(&iter, &subiter);
    if (strcmp(dbus_message_iter_get_signature(&subiter), "i")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "i", dbus_message_iter_get_signature(&subiter));
        dbus_message_unref(reply);
        return 0;
    }
    dbus_message_iter_get_basic(&subiter, &_tmp78_);
    dbus_message_iter_next(&subiter);
    _result = _tmp78_;
    dbus_message_unref(reply);
    return _result;
}


static void awn_panel_dbus_interface_dbus_proxy_set_size(AwnPanelDBusInterface* self, gint value)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;
    DBusMessageIter iter, subiter;
    const char* _tmp79_;
    const char* _tmp80_;
    dbus_int32_t _tmp81_;
    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        return;
    }
    DBusMessage* msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
    dbus_message_iter_init_append(msg, &iter);
    _tmp79_ = "org.awnproject.Awn.Panel";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp79_);
    _tmp80_ = "Size";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &_tmp80_);
    dbus_message_iter_open_container(&iter, DBUS_TYPE_VARIANT, "i", &subiter);
    _tmp81_ = value;
    dbus_message_iter_append_basic(&subiter, DBUS_TYPE_INT32, &_tmp81_);
    dbus_message_iter_close_container(&iter, &subiter);
    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);
    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);
    if (dbus_error_is_set(&_dbus_error)) {
        g_critical("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
        dbus_error_free(&_dbus_error);
        return;
    }
    if (strcmp(dbus_message_get_signature(reply), "")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return;
    }
    dbus_message_iter_init(reply, &iter);
    dbus_message_unref(reply);
}


static gint64 awn_panel_dbus_interface_dbus_proxy_get_panel_xid(AwnPanelDBusInterface* self)
{
    DBusError _dbus_error;
    DBusGConnection* _connection;

    if (((AwnPanelDBusInterfaceDBusProxy*) self)->disposed) {
        return 0;
    }
    DBusMessage* msg = dbus_message_new_method_call(dbus_g_proxy_get_bus_name((DBusGProxy*) self), dbus_g_proxy_get_path((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
    DBusMessageIter iter;
    dbus_message_iter_init_append(msg, &iter);

    const char* s1 = "org.awnproject.Awn.Panel";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &s1);
    const char* s2 = "PanelXid";
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &s2);

    g_object_get(self, "connection", &_connection, NULL);
    dbus_error_init(&_dbus_error);

    DBusMessage* reply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(_connection), msg, -1, &_dbus_error);
    dbus_g_connection_unref(_connection);
    dbus_message_unref(msg);

    if (dbus_error_is_set(&_dbus_error)) {
        g_critical("file %s: line %d: uncaught error: %s (%s)",
                   __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
        dbus_error_free(&_dbus_error);
        return 0;
    }

    if (strcmp(dbus_message_get_signature(reply), "v")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"",
                   __FILE__, __LINE__, "v", dbus_message_get_signature(reply));
        dbus_message_unref(reply);
        return 0;
    }

    dbus_message_iter_init(reply, &iter);

    DBusMessageIter subiter;
    dbus_message_iter_recurse(&iter, &subiter);
    if (strcmp(dbus_message_iter_get_signature(&subiter), "x")) {
        g_critical("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"",
                   __FILE__, __LINE__, "x", dbus_message_iter_get_signature(&subiter));
        dbus_message_unref(reply);
        return 0;
    }

    dbus_int64_t res;
    dbus_message_iter_get_basic(&subiter, &res);
    dbus_message_iter_next(&subiter);
    dbus_message_unref(reply);
    return res;
}


static void awn_panel_dbus_interface_dbus_proxy_awn_panel_dbus_interface__interface_init(AwnPanelDBusInterfaceIface* iface)
{
    iface->add_applet = awn_panel_dbus_interface_dbus_proxy_add_applet;
    iface->delete_applet = awn_panel_dbus_interface_dbus_proxy_delete_applet;
    iface->docklet_request = awn_panel_dbus_interface_dbus_proxy_docklet_request;
    iface->get_inhibitors = awn_panel_dbus_interface_dbus_proxy_get_inhibitors;
    iface->get_snapshot = awn_panel_dbus_interface_dbus_proxy_get_snapshot;
    iface->inhibit_autohide = awn_panel_dbus_interface_dbus_proxy_inhibit_autohide;
    iface->uninhibit_autohide = awn_panel_dbus_interface_dbus_proxy_uninhibit_autohide;
    iface->set_applet_flags = awn_panel_dbus_interface_dbus_proxy_set_applet_flags;
    iface->set_glow = awn_panel_dbus_interface_dbus_proxy_set_glow;
    iface->get_offset_modifier = awn_panel_dbus_interface_dbus_proxy_get_offset_modifier;
    iface->get_max_size = awn_panel_dbus_interface_dbus_proxy_get_max_size;
    iface->get_offset = awn_panel_dbus_interface_dbus_proxy_get_offset;
    iface->set_offset = awn_panel_dbus_interface_dbus_proxy_set_offset;
    iface->get_path_type = awn_panel_dbus_interface_dbus_proxy_get_path_type;
    iface->get_position = awn_panel_dbus_interface_dbus_proxy_get_position;
    iface->set_position = awn_panel_dbus_interface_dbus_proxy_set_position;
    iface->get_size = awn_panel_dbus_interface_dbus_proxy_get_size;
    iface->set_size = awn_panel_dbus_interface_dbus_proxy_set_size;
    iface->get_panel_xid = awn_panel_dbus_interface_dbus_proxy_get_panel_xid;
}


static void _vala_awn_panel_dbus_interface_dbus_proxy_get_property(GObject* object, guint property_id, GValue* value, GParamSpec* pspec)
{
}


static void _vala_awn_panel_dbus_interface_dbus_proxy_set_property(GObject* object, guint property_id, const GValue* value, GParamSpec* pspec)
{
}


static void _lambda0_(AwnPanel* p, gint s, AwnPanelDispatcher* self)
{
    GValue val = {0};
    g_return_if_fail(p != NULL);
    g_value_init(&val, G_TYPE_INT);
    g_value_set_int(&val, s);
    g_signal_emit_by_name((AwnPanelDBusInterface*) self, "property-changed", "size", &val);
    G_IS_VALUE(&val) ? (g_value_unset(&val), NULL) : NULL;
}


static void __lambda0__awn_panel_size_changed(AwnPanel* _sender, gint size, gpointer self)
{
    _lambda0_(_sender, size, self);
}


static void _lambda1_(AwnPanel* p, gint pos, AwnPanelDispatcher* self)
{
    GValue val = {0};
    g_return_if_fail(p != NULL);
    g_value_init(&val, G_TYPE_INT);
    g_value_set_int(&val, pos);
    g_signal_emit_by_name((AwnPanelDBusInterface*) self, "property-changed", "position", &val);
    G_IS_VALUE(&val) ? (g_value_unset(&val), NULL) : NULL;
}


static void __lambda1__awn_panel_position_changed(AwnPanel* _sender, gint position, gpointer self)
{
    _lambda1_(_sender, position, self);
}


static void _lambda2_(AwnPanel* p, gint o, AwnPanelDispatcher* self)
{
    GValue val = {0};
    g_return_if_fail(p != NULL);
    g_value_init(&val, G_TYPE_INT);
    g_value_set_int(&val, o);
    g_signal_emit_by_name((AwnPanelDBusInterface*) self, "property-changed", "offset", &val);
    G_IS_VALUE(&val) ? (g_value_unset(&val), NULL) : NULL;
}


static void __lambda2__awn_panel_offset_changed(AwnPanel* _sender, gint offset, gpointer self)
{
    _lambda2_(_sender, offset, self);
}


static void _lambda3_(AwnPanel* p, const gchar* pn, GValue* v, AwnPanelDispatcher* self)
{
    g_return_if_fail(p != NULL);
    g_return_if_fail(pn != NULL);
    g_signal_emit_by_name((AwnPanelDBusInterface*) self, "property-changed", pn, v);
}


static void __lambda3__awn_panel_property_changed(AwnPanel* _sender, const gchar* prop_name, GValue* val, gpointer self)
{
    _lambda3_(_sender, prop_name, val, self);
}


AwnPanelDispatcher* awn_panel_dispatcher_construct(GType object_type, AwnPanel* panel)
{
    GError* _inner_error_ = NULL;
    g_return_val_if_fail(panel != NULL, NULL);
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) g_object_new(object_type, "panel", panel, NULL);
    g_signal_connect_object(panel, "size-changed", (GCallback) __lambda0__awn_panel_size_changed, self, 0);
    g_signal_connect_object(panel, "position-changed", (GCallback) __lambda1__awn_panel_position_changed, self, 0);
    g_signal_connect_object(panel, "offset-changed", (GCallback) __lambda2__awn_panel_offset_changed, self, 0);
    g_signal_connect_object(panel, "property-changed", (GCallback) __lambda3__awn_panel_property_changed, self, 0);
    DBusGConnection* conn = dbus_g_bus_get(DBUS_BUS_SESSION, &_inner_error_);
    if (_inner_error_ != NULL) {
        g_critical("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string(_inner_error_->domain), _inner_error_->code);
        g_clear_error(&_inner_error_);
        return NULL;
    }

    int panel_id;
    g_object_get(panel, "panel-id", &panel_id, NULL);
    std::string obj_path{"/org/awnproject/Awn/Panel"};
    obj_path += std::to_string(panel_id);

    _vala_dbus_register_object(dbus_g_connection_get_connection(conn), obj_path.c_str(), (GObject*) self);
    _dbus_g_connection_unref0(conn);
    return self;
}


AwnPanelDispatcher* awn_panel_dispatcher_new(AwnPanel* panel)
{
    return awn_panel_dispatcher_construct(AWN_TYPE_PANEL_DISPATCHER, panel);
}


static void awn_panel_dispatcher_real_add_applet(AwnPanelDBusInterface* base, const gchar* desktop_file, GError** error)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    GError* _inner_error_ = NULL;
    g_return_if_fail(desktop_file != NULL);
    awn_panel_add_applet(self->priv->_panel, desktop_file, &_inner_error_);
    if (_inner_error_ != NULL) {
        if (_inner_error_->domain == DBUS_GERROR) {
            g_propagate_error(error, _inner_error_);
        } else {
            g_critical("file %s: line %d: uncaught error: %s (%s, %d)",
                       __FILE__, __LINE__, _inner_error_->message,
                       g_quark_to_string(_inner_error_->domain), _inner_error_->code);
            g_clear_error(&_inner_error_);
        }
    }
}


static void awn_panel_dispatcher_real_delete_applet(AwnPanelDBusInterface* base, const gchar* uid, GError** error)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    GError* _inner_error_ = NULL;
    g_return_if_fail(uid != NULL);
    awn_panel_delete_applet(self->priv->_panel, uid, &_inner_error_);
    if (_inner_error_ != NULL) {
        if (_inner_error_->domain == DBUS_GERROR) {
            g_propagate_error(error, _inner_error_);
        } else {
            g_critical("file %s: line %d: uncaught error: %s (%s, %d)",
                       __FILE__, __LINE__, _inner_error_->message,
                       g_quark_to_string(_inner_error_->domain), _inner_error_->code);
            g_clear_error(&_inner_error_);
        }
    }
}


static gint64 awn_panel_dispatcher_real_docklet_request(AwnPanelDBusInterface* base, gint min_size, gboolean shrink, gboolean expand, GError** error)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    GError* _inner_error_ = NULL;
    gint64 req = awn_panel_docklet_request(self->priv->_panel, min_size, shrink, expand, &_inner_error_);
    if (_inner_error_ != NULL) {
        if (_inner_error_->domain == DBUS_GERROR) {
            g_propagate_error(error, _inner_error_);
            return 0LL;
        } else {
            g_critical("file %s: line %d: uncaught error: %s (%s, %d)",
                       __FILE__, __LINE__, _inner_error_->message,
                       g_quark_to_string(_inner_error_->domain), _inner_error_->code);
            g_clear_error(&_inner_error_);
            return 0LL;
        }
    }
    return req;
}


static gchar** awn_panel_dispatcher_real_get_inhibitors(AwnPanelDBusInterface* base, int* result_length1, GError** error)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    char** reasons = awn_panel_get_inhibitors(self->priv->_panel);
    int reasons_length = _vala_array_length(reasons);
    if (result_length1) {
        *result_length1 = reasons_length;
    }
    return reasons;
}


static void awn_panel_dispatcher_real_get_snapshot(AwnPanelDBusInterface* base, AwnImageStruct* result, GError** error)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    AwnImageStruct tmp_res;
    GError* _inner_error_ = NULL;
    awn_panel_get_snapshot(self->priv->_panel, &tmp_res, &_inner_error_);
    if (_inner_error_ != NULL) {
        if (_inner_error_->domain == DBUS_GERROR) {
            g_propagate_error(error, _inner_error_);
            awn_image_struct_destroy(&tmp_res);
            return;
        } else {
            awn_image_struct_destroy(&tmp_res);
            g_critical("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__,
                       __LINE__, _inner_error_->message,
                       g_quark_to_string(_inner_error_->domain), _inner_error_->code);
            g_clear_error(&_inner_error_);
            return;
        }
    }
    *result = tmp_res;
    return;
}


static guint awn_panel_dispatcher_real_inhibit_autohide(AwnPanelDBusInterface* base, const char* sender, const gchar* app_name, const gchar* reason, GError** error)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    guint _tmp0_;
    g_return_val_if_fail(sender != NULL, 0U);
    g_return_val_if_fail(app_name != NULL, 0U);
    g_return_val_if_fail(reason != NULL, 0U);
    return awn_panel_inhibit_autohide(self->priv->_panel, (const gchar*) sender, app_name, reason);
}


static void awn_panel_dispatcher_real_uninhibit_autohide(AwnPanelDBusInterface* base, guint cookie, GError** error)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    awn_panel_uninhibit_autohide(self->priv->_panel, cookie);
}


static void awn_panel_dispatcher_real_set_applet_flags(AwnPanelDBusInterface* base, const gchar* uid, gint flags, GError** error)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    GError* _inner_error_ = NULL;
    g_return_if_fail(uid != NULL);
    awn_panel_set_applet_flags(self->priv->_panel, uid, flags, &_inner_error_);
    if (_inner_error_ != NULL) {
        if (_inner_error_->domain == DBUS_GERROR) {
            g_propagate_error(error, _inner_error_);
            return;
        } else {
            g_critical("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string(_inner_error_->domain), _inner_error_->code);
            g_clear_error(&_inner_error_);
            return;
        }
    }
}


static void awn_panel_dispatcher_real_set_glow(AwnPanelDBusInterface* base, const char* sender, gboolean activate, GError** error)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    g_return_if_fail(sender != NULL);
    awn_panel_set_glow(self->priv->_panel, (const gchar*) sender, activate);
}


AwnPanel* awn_panel_dispatcher_get_panel(AwnPanelDispatcher* self)
{
    g_return_val_if_fail(self != NULL, NULL);
    return self->priv->_panel;
}


static void awn_panel_dispatcher_set_panel(AwnPanelDispatcher* self, AwnPanel* value)
{
    g_return_if_fail(self != NULL);
    self->priv->_panel = value;
    g_object_notify((GObject*) self, "panel");
}


static gdouble awn_panel_dispatcher_real_get_offset_modifier(AwnPanelDBusInterface* base)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    float result;
    g_object_get(self->priv->_panel, "offset-modifier", &result, NULL);
    return result;
}


static gint awn_panel_dispatcher_real_get_max_size(AwnPanelDBusInterface* base)
{
    AwnPanelDispatcher* self =(AwnPanelDispatcher*) base;
    int result;
    g_object_get(self->priv->_panel, "max-size", &result, NULL);
    return result;
}


static gint awn_panel_dispatcher_real_get_offset(AwnPanelDBusInterface* base)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    int result;
    g_object_get(self->priv->_panel, "offset", &result, NULL);
    return result;
}


static void awn_panel_dispatcher_real_set_offset(AwnPanelDBusInterface* base, gint value)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    g_object_set(self->priv->_panel, "offset", value, NULL);
}


static gint awn_panel_dispatcher_real_get_path_type(AwnPanelDBusInterface* base)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    int result;
    g_object_get(self->priv->_panel, "path-type", &result, NULL);
    return result;
}


static gint awn_panel_dispatcher_real_get_position(AwnPanelDBusInterface* base)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    int result;
    g_object_get(self->priv->_panel, "position", &result, NULL);
    return result;
}


static void awn_panel_dispatcher_real_set_position(AwnPanelDBusInterface* base, gint value)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    g_object_set(self->priv->_panel, "position", value, NULL);
}


static gint awn_panel_dispatcher_real_get_size(AwnPanelDBusInterface* base)
{
    gint result;
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    g_object_get(self->priv->_panel, "size", &result, NULL);
    return result;
}


static void awn_panel_dispatcher_real_set_size(AwnPanelDBusInterface* base, gint value)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    g_object_set(self->priv->_panel, "size", value, NULL);
}


static gint64 awn_panel_dispatcher_real_get_panel_xid(AwnPanelDBusInterface* base)
{
    AwnPanelDispatcher* self = (AwnPanelDispatcher*) base;
    gint64 result;
    g_object_get(self->priv->_panel, "panel-xid", &result, NULL);
    return result;
}


static void awn_panel_dispatcher_class_init(AwnPanelDispatcherClass* klass)
{
    awn_panel_dispatcher_parent_class = g_type_class_peek_parent(klass);
    g_type_class_add_private(klass, sizeof(AwnPanelDispatcherPrivate));
    G_OBJECT_CLASS(klass)->get_property = _vala_awn_panel_dispatcher_get_property;
    G_OBJECT_CLASS(klass)->set_property = _vala_awn_panel_dispatcher_set_property;
    G_OBJECT_CLASS(klass)->finalize = awn_panel_dispatcher_finalize;
    g_object_class_install_property(G_OBJECT_CLASS(klass), AWN_PANEL_DISPATCHER_PANEL, g_param_spec_object("panel", "panel", "panel", AWN_TYPE_PANEL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void awn_panel_dispatcher_awn_panel_dbus_interface_interface_init(AwnPanelDBusInterfaceIface* iface)
{
    awn_panel_dispatcher_awn_panel_dbus_interface_parent_iface = g_type_interface_peek_parent(iface);
    iface->add_applet = (void (*)(AwnPanelDBusInterface* , const gchar* , GError**)) awn_panel_dispatcher_real_add_applet;
    iface->delete_applet = (void (*)(AwnPanelDBusInterface* , const gchar* , GError**)) awn_panel_dispatcher_real_delete_applet;
    iface->docklet_request = (gint64(*)(AwnPanelDBusInterface* , gint , gboolean , gboolean , GError**)) awn_panel_dispatcher_real_docklet_request;
    iface->get_inhibitors = (gchar** (*)(AwnPanelDBusInterface* , int* , GError**)) awn_panel_dispatcher_real_get_inhibitors;
    iface->get_snapshot = (AwnImageStruct(*)(AwnPanelDBusInterface* , AwnImageStruct* , GError**)) awn_panel_dispatcher_real_get_snapshot;
    iface->inhibit_autohide = (guint(*)(AwnPanelDBusInterface* , const char* , const gchar* , const gchar* , GError**)) awn_panel_dispatcher_real_inhibit_autohide;
    iface->uninhibit_autohide = (void (*)(AwnPanelDBusInterface* , guint , GError**)) awn_panel_dispatcher_real_uninhibit_autohide;
    iface->set_applet_flags = (void (*)(AwnPanelDBusInterface* , const gchar* , gint , GError**)) awn_panel_dispatcher_real_set_applet_flags;
    iface->set_glow = (void (*)(AwnPanelDBusInterface* , const char* , gboolean , GError**)) awn_panel_dispatcher_real_set_glow;
    iface->get_offset_modifier = awn_panel_dispatcher_real_get_offset_modifier;
    iface->get_max_size = awn_panel_dispatcher_real_get_max_size;
    iface->get_offset = awn_panel_dispatcher_real_get_offset;
    iface->set_offset = awn_panel_dispatcher_real_set_offset;
    iface->get_path_type = awn_panel_dispatcher_real_get_path_type;
    iface->get_position = awn_panel_dispatcher_real_get_position;
    iface->set_position = awn_panel_dispatcher_real_set_position;
    iface->get_size = awn_panel_dispatcher_real_get_size;
    iface->set_size = awn_panel_dispatcher_real_set_size;
    iface->get_panel_xid = awn_panel_dispatcher_real_get_panel_xid;
}


static void awn_panel_dispatcher_instance_init(AwnPanelDispatcher* self)
{
    self->priv = AWN_PANEL_DISPATCHER_GET_PRIVATE(self);
}


static void awn_panel_dispatcher_finalize(GObject* obj)
{
    G_OBJECT_CLASS(awn_panel_dispatcher_parent_class)->finalize(obj);
}


void _awn_panel_dispatcher_dbus_unregister(DBusConnection* connection, void* _user_data_)
{
}


static DBusHandlerResult _dbus_awn_panel_dispatcher_introspect(AwnPanelDispatcher* self, DBusConnection* connection, DBusMessage* message)
{
    char** children;
    DBusMessage* reply = dbus_message_new_method_return(message);

    DBusMessageIter iter;
    dbus_message_iter_init_append(reply, &iter);

    std::string xml_data{"<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n"};
    xml_data += "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"org.awnproject.Awn.Panel\">\n  <method name=\"AddApplet\">\n    <arg name=\"desktop_file\" type=\"s\" direction=\"in\"/>\n  </method>\n  <method name=\"DeleteApplet\">\n    <arg name=\"uid\" type=\"s\" direction=\"in\"/>\n  </method>\n  <method name=\"DockletRequest\">\n    <arg name=\"min_size\" type=\"i\" direction=\"in\"/>\n    <arg name=\"shrink\" type=\"b\" direction=\"in\"/>\n    <arg name=\"expand\" type=\"b\" direction=\"in\"/>\n    <arg name=\"result\" type=\"x\" direction=\"out\"/>\n  </method>\n  <method name=\"GetInhibitors\">\n    <arg name=\"result\" type=\"as\" direction=\"out\"/>\n  </method>\n  <method name=\"GetSnapshot\">\n    <arg name=\"result\" type=\"(iiibiiay)\" direction=\"out\"/>\n  </method>\n  <method name=\"InhibitAutohide\">\n    <arg name=\"app_name\" type=\"s\" direction=\"in\"/>\n    <arg name=\"reason\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"u\" direction=\"out\"/>\n  </method>\n  <method name=\"UninhibitAutohide\">\n    <arg name=\"cookie\" type=\"u\" direction=\"in\"/>\n  </method>\n  <method name=\"SetAppletFlags\">\n    <arg name=\"uid\" type=\"s\" direction=\"in\"/>\n    <arg name=\"flags\" type=\"i\" direction=\"in\"/>\n  </method>\n  <method name=\"SetGlow\">\n    <arg name=\"activate\" type=\"b\" direction=\"in\"/>\n  </method>\n  <property name=\"OffsetModifier\" type=\"d\" access=\"read\"/>\n  <property name=\"MaxSize\" type=\"i\" access=\"read\"/>\n  <property name=\"Offset\" type=\"i\" access=\"readwrite\"/>\n  <property name=\"PathType\" type=\"i\" access=\"read\"/>\n  <property name=\"Position\" type=\"i\" access=\"readwrite\"/>\n  <property name=\"Size\" type=\"i\" access=\"readwrite\"/>\n  <property name=\"PanelXid\" type=\"x\" access=\"read\"/>\n  <signal name=\"DestroyApplet\">\n    <arg name=\"uid\" type=\"s\"/>\n  </signal>\n  <signal name=\"DestroyNotify\">\n  </signal>\n  <signal name=\"PropertyChanged\">\n    <arg name=\"prop_name\" type=\"s\"/>\n    <arg name=\"value\" type=\"v\"/>\n  </signal>\n</interface>\n";
    dbus_connection_list_registered(connection, g_object_get_data((GObject*) self, "dbus_object_path"), &children);
    for (int i = 0; children[i]; i++) {
        xml_data = xml_data + "<node name=\"" + children[i] + "\"/>\n";
    }
    dbus_free_string_array(children);
    xml_data += "</node>\n";
    const char* str = xml_data.c_str();
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &str);
    if (reply) {
        dbus_connection_send(connection, reply, NULL);
        dbus_message_unref(reply);
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


DBusHandlerResult awn_panel_dispatcher_dbus_message(DBusConnection* connection, DBusMessage* message, void* object)
{
    DBusHandlerResult result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    if (dbus_message_is_method_call(message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
        result = _dbus_awn_panel_dispatcher_introspect(object, connection, message);
    }
    if (result == DBUS_HANDLER_RESULT_HANDLED) {
        return result;
    } else if (awn_panel_dbus_interface_dbus_message(connection, message, object) == DBUS_HANDLER_RESULT_HANDLED) {
        return DBUS_HANDLER_RESULT_HANDLED;
    } else {
        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
    }
}


void awn_panel_dispatcher_dbus_register_object(DBusConnection* connection, const char* path, void* object)
{
    if (!g_object_get_data(object, "dbus_object_path")) {
        g_object_set_data(object, "dbus_object_path", g_strdup(path));
        dbus_connection_register_object_path(connection, path, &_awn_panel_dispatcher_dbus_path_vtable, object);
        g_object_weak_ref(object, _vala_dbus_unregister_object, connection);
    }
    awn_panel_dbus_interface_dbus_register_object(connection, path, object);
}


GType awn_panel_dispatcher_get_type(void)
{
    static volatile gsize type_id = 0;
    if (g_once_init_enter(&type_id)) {
        static const GTypeInfo g_define_type_info = { sizeof(AwnPanelDispatcherClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) awn_panel_dispatcher_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof(AwnPanelDispatcher), 0, (GInstanceInitFunc) awn_panel_dispatcher_instance_init, NULL };
        static const GInterfaceInfo awn_panel_dbus_interface_info = { (GInterfaceInitFunc) awn_panel_dispatcher_awn_panel_dbus_interface_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
        GType awn_panel_dispatcher_type_id;
        awn_panel_dispatcher_type_id = g_type_register_static(G_TYPE_OBJECT, "AwnPanelDispatcher", &g_define_type_info, 0);
        g_type_add_interface_static(awn_panel_dispatcher_type_id, AWN_TYPE_PANEL_DBUS_INTERFACE, &awn_panel_dbus_interface_info);
        g_type_set_qdata(awn_panel_dispatcher_type_id, g_quark_from_static_string("DBusObjectVTable"), (void*)(&_awn_panel_dispatcher_dbus_vtable));
        g_once_init_leave(&type_id, awn_panel_dispatcher_type_id);
    }
    return type_id;
}


static void _vala_awn_panel_dispatcher_get_property(GObject* object, guint property_id, GValue* value, GParamSpec* pspec)
{
    AwnPanelDispatcher* self = AWN_PANEL_DISPATCHER(object);
    switch (property_id) {
    case AWN_PANEL_DISPATCHER_PANEL:
        g_value_set_object(value, awn_panel_dispatcher_get_panel(self));
        break;
    default:
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}


static void _vala_awn_panel_dispatcher_set_property(GObject* object, guint property_id, const GValue* value, GParamSpec* pspec)
{
    AwnPanelDispatcher* self = AWN_PANEL_DISPATCHER(object);
    switch (property_id) {
    case AWN_PANEL_DISPATCHER_PANEL:
        awn_panel_dispatcher_set_panel(self, g_value_get_object(value));
        break;
    default:
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}


static gint _vala_array_length(gpointer array)
{
    int length = 0;
    if (array) {
        while (((gpointer*) array)[length]) {
            length++;
        }
    }
    return length;
}



